% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/database.R
\name{pgUpdate}
\alias{pgUpdate}
\title{update a database table with 'updated' data}
\usage{
pgUpdate(con, trgt = NULL, keys = c("rn"), schname, df = NULL,
  varHint = NULL, valHint = NULL, ...)
}
\arguments{
\item{con}{DBI connection PostgreSQL}

\item{trgt}{remote server side string database table name of old data}

\item{keys}{trgt remote server side vector of strings of table
column names that make up a unique id for the row.
keys can not be zero length. keys can not be null.}

\item{schname}{schema name}

\item{df}{local client side data.frame of 'updated data'}

\item{varHint}{optional vector of character column names. Performance optimization
techique to limit the number of rows returned
from the database server to the client(R).
User must specify as paired position values.
e.g. varHint = "dateindex", valHint = "17000"
or e.g. varHint = c("dateindex", "ticker"), valHint = c("17000","'AAPL'")
Position matches one to one with valHint
Note, also for performance reasons,
the unique combinations of the keys of the 'updated data' data.frame df
are sent to the server, also, the reason is to limit the number of rows returned from the server.}

\item{valHint}{See varHint. Position matches one to one with varHint.}

\item{prepare.query}{FALSE(default) will use RPostgres PostgreSQLConnection
If TRUE, will use package RPostgre PqConnection}

\item{password}{(REQUIRED if prepare.query == TRUE) passed
to package RPostgres dbConnect to create a
class PqConnection connection.  This is needed to to a prepare.query
and create an intermediate TEMPORARY TABLE on the database server.
An alternative way to to specify the password is throught the environment
variable PGPASS.  E.g. Sys.setenv("PGPASSWORD" = "postgres")}
}
\description{
TODO [ ] dbQuote* valHint
TODO [TOMORROW] part of dbUpsert <- function() { pgAddColumn, pgInsert, pgUpdate }
}
\examples{
\dontrun{

# setup
SuBmtcars <- mtcars[c(1,5),1:2]
oldData <- data.table::data.table(SuBmtcars, keep.rownames=TRUE, key="rn")
rownames(oldData) <- NULL
oldData[1,2] <- NA; oldData[2,3] <- NA

con <- DBI::dbConnect(RPostgreSQL::PostgreSQL(), user = "postgres")
DBI::dbWriteTable(con, "mtcars", oldData, row.names = FALSE)

newData <- data.table::data.table(SuBmtcars, keep.rownames=TRUE, key="rn")
rownames(newData) <- NULL
newData[2,2] <- NA; newData[1,3] <- NA

# not "prepare.query"
pgUpdate(con, trgt = "mtcars", keys = c("rn"), schname = "public", df = newData)

# "prepare.query"
dbExecute(con, "DROP TABLE mtcars")
DBI::dbWriteTable(con, "mtcars", oldData, row.names = FALSE)
pgUpdate(con, trgt = "mtcars", keys = c("rn"), schname = "public",
  df = newData, prepare.query = TRUE, password = "postgres")

DBI::dbDisconnect(con)

}
\dontrun{


}
}
